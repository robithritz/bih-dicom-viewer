<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DICOM Viewer - <%= filename %>
    </title>

    <!-- Cornerstone.js and dependencies -->
    <script src="https://unpkg.com/cornerstone-core@2.6.1/dist/cornerstone.min.js"></script>
    <script src="https://unpkg.com/cornerstone-math@0.1.9/dist/cornerstoneMath.min.js"></script>
    <script src="https://unpkg.com/cornerstone-tools@6.0.10/dist/cornerstoneTools.min.js"></script>
    <script
        src="https://unpkg.com/cornerstone-web-image-loader@2.1.1/dist/cornerstoneWebImageLoader.bundle.min.js"></script>
    <script
        src="https://unpkg.com/cornerstone-wado-image-loader@4.13.2/dist/cornerstoneWADOImageLoader.bundle.min.js"></script>
    <script src="https://unpkg.com/dicom-parser@1.8.21/dist/dicomParser.min.js"></script>
    <script src="https://unpkg.com/hammerjs@2.0.8/hammer.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #ffffff;
            overflow: hidden;
        }

        .viewer-container {
            display: flex;
            height: 100vh;
        }

        .file-browser {
            width: 250px;
            background-color: #2a2a2a;
            border-right: 1px solid #444;
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease;
        }

        .file-browser.collapsed {
            width: 40px;
        }

        .file-browser-header {
            padding: 15px;
            background-color: #333;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-browser-header h3 {
            margin: 0;
            color: #ffaa00;
            font-size: 14px;
        }

        .toggle-btn {
            background: none;
            border: none;
            color: #ffaa00;
            cursor: pointer;
            font-size: 16px;
            padding: 5px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }

        .toggle-btn:hover {
            background-color: rgba(255, 170, 0, 0.1);
        }

        .file-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .file-item {
            padding: 8px 12px;
            margin: 2px 0;
            background-color: #333;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 3px solid transparent;
            font-size: 12px;
            color: #ccc;
        }

        .file-item:hover {
            background-color: #444;
            color: #fff;
        }

        .file-item.active {
            background-color: #ffaa00;
            color: #000;
            border-left-color: #ff8800;
            font-weight: bold;
        }

        .file-item.loading {
            opacity: 0.6;
            pointer-events: none;
        }

        .file-browser.collapsed .file-browser-header h3,
        .file-browser.collapsed .file-list {
            display: none;
        }

        .file-browser.collapsed .toggle-btn {
            transform: rotate(180deg);
        }

        .sidebar {
            width: 300px;
            background-color: #2d2d2d;
            border-right: 1px solid #444;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .main-viewer {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            background-color: #333;
            padding: 10px;
            border-bottom: 1px solid #444;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .tool-group {
            display: flex;
            gap: 5px;
            align-items: center;
            padding: 0 10px;
            border-right: 1px solid #555;
        }

        .tool-group:last-child {
            border-right: none;
        }

        .tool-btn {
            background-color: #555;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }

        .tool-btn:hover {
            background-color: #666;
        }

        .tool-btn.active {
            background-color: #007acc;
        }

        .viewport-container {
            flex: 1;
            position: relative;
            background-color: #000;
        }

        .viewport {
            width: 100%;
            height: 100%;
            background-color: #000;
        }

        .info-panel {
            padding: 15px;
            border-bottom: 1px solid #444;
        }

        .info-panel h3 {
            color: #007acc;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .info-label {
            color: #ccc;
            font-weight: bold;
        }

        .info-value {
            color: #fff;
        }

        .controls-panel {
            padding: 15px;
            border-bottom: 1px solid #444;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            color: #ccc;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .control-input {
            width: 100%;
            background-color: #444;
            border: 1px solid #555;
            color: white;
            padding: 5px;
            border-radius: 3px;
            font-size: 12px;
        }

        .range-input {
            width: 100%;
            margin: 5px 0;
        }

        .viewport-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
            pointer-events: none;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #007acc;
            font-size: 18px;
        }

        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            text-align: center;
        }

        .back-btn {
            background-color: #007acc;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            text-decoration: none;
            font-size: 12px;
            display: inline-block;
        }

        .back-btn:hover {
            background-color: #005a9e;
        }

        .rotation-display {
            color: #00ff88;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
            padding: 2px 6px;
            background-color: rgba(0, 255, 136, 0.1);
            border-radius: 3px;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .frame-display {
            color: #ffaa00;
            font-size: 12px;
            font-weight: bold;
            padding: 2px 8px;
            background-color: rgba(255, 170, 0, 0.1);
            border-radius: 3px;
            border: 1px solid rgba(255, 170, 0, 0.3);
            min-width: 40px;
            text-align: center;
        }

        .frame-counter {
            color: #ffaa00;
            font-size: 14px;
            font-weight: bold;
            padding: 4px 8px;
            background-color: rgba(255, 170, 0, 0.1);
            border-radius: 3px;
            border: 1px solid rgba(255, 170, 0, 0.3);
            text-align: center;
            display: block;
            margin-bottom: 10px;
        }

        .frame-scroll-container {
            position: relative;
            height: 200px;
            margin: 10px 0;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: #1a1a1a;
        }

        .frame-scroll-area {
            width: 100%;
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            cursor: grab;
        }

        .frame-scroll-area:active {
            cursor: grabbing;
        }

        .frame-scroll-content {
            width: 100%;
            background: linear-gradient(to bottom,
                    #ffaa00 0%,
                    #ff8800 25%,
                    #ff6600 50%,
                    #ff4400 75%,
                    #ff2200 100%);
            position: relative;
            min-height: 100%;
        }

        .frame-scroll-indicator {
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            width: 3px;
            height: 20px;
            background-color: #00ff88;
            border-radius: 2px;
            pointer-events: none;
            transition: all 0.2s ease;
        }

        /* Custom scrollbar for frame scroll area */
        .frame-scroll-area::-webkit-scrollbar {
            width: 8px;
        }

        .frame-scroll-area::-webkit-scrollbar-track {
            background: #2a2a2a;
            border-radius: 4px;
        }

        .frame-scroll-area::-webkit-scrollbar-thumb {
            background: #ffaa00;
            border-radius: 4px;
        }

        .frame-scroll-area::-webkit-scrollbar-thumb:hover {
            background: #ff8800;
        }
    </style>
</head>

<body>
    <div class="viewer-container">
        <div class="file-browser" id="fileBrowser">
            <div class="file-browser-header">
                <h3>📁 DICOM Files</h3>
                <button class="toggle-btn" onclick="toggleFileBrowser()">◀</button>
            </div>
            <div class="file-list" id="fileList">
                <!-- Files will be populated by JavaScript -->
            </div>
        </div>

        <div class="sidebar">
            <div class="info-panel">
                <h3>📄 File Information</h3>
                <div class="info-row">
                    <span class="info-label">Filename:</span>
                    <span class="info-value">
                        <%= filename %>
                    </span>
                </div>
                <div class="info-row">
                    <span class="info-label">Patient:</span>
                    <span class="info-value" id="patientName">Loading...</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Study Date:</span>
                    <span class="info-value" id="studyDate">Loading...</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Modality:</span>
                    <span class="info-value" id="modality">Loading...</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Dimensions:</span>
                    <span class="info-value" id="dimensions">Loading...</span>
                </div>
            </div>

            <div class="controls-panel">
                <h3>🎛️ Window/Level</h3>
                <div class="control-group">
                    <label for="windowWidth">Window Width:</label>
                    <input type="range" id="windowWidth" class="range-input" min="1" max="4000" value="400">
                    <input type="number" id="windowWidthValue" class="control-input" value="400">
                </div>
                <div class="control-group">
                    <label for="windowCenter">Window Center:</label>
                    <input type="range" id="windowCenter" class="range-input" min="-1000" max="3000" value="40">
                    <input type="number" id="windowCenterValue" class="control-input" value="40">
                </div>
            </div>

            <div class="controls-panel">
                <h3>🔍 Zoom & Pan</h3>
                <div class="control-group">
                    <label for="zoomLevel">Zoom Level:</label>
                    <input type="range" id="zoomLevel" class="range-input" min="0.1" max="5" step="0.1" value="1">
                    <input type="number" id="zoomLevelValue" class="control-input" step="0.1" value="1">
                </div>
                <button class="tool-btn" onclick="resetView()">Reset View</button>
            </div>

            <div class="controls-panel" id="frameNavigation">
                <h3>🎬 Frame Navigation</h3>
                <div class="control-group">
                    <span class="frame-counter" id="frameCounter">1/1</span>
                </div>
                <div class="frame-scroll-container">
                    <div class="frame-scroll-area" id="frameScrollArea">
                        <div class="frame-scroll-content" id="frameScrollContent">
                            <!-- Scroll content will be dynamically sized based on frame count -->
                        </div>
                    </div>
                    <div class="frame-scroll-indicator" id="frameScrollIndicator"></div>
                </div>
                <div class="control-group">
                    <small style="color: #888;">
                        🖱️ Scroll up/down to navigate frames<br>
                        📍 Top = Frame 1, Bottom = Last Frame<br>
                        ⌨️ Arrow keys (← →) also work
                    </small>
                </div>
            </div>

            <div class="controls-panel" id="seriesNavigation" style="display: none;">
                <h3>📚 Series Navigation</h3>
                <div class="control-group">
                    <label>Current Series:</label>
                    <select id="seriesSelector" class="control-input" onchange="switchSeries()">
                        <!-- Options populated by JavaScript -->
                    </select>
                </div>
                <div class="control-group">
                    <label>Instance: <span id="currentInstance">1</span> of <span id="totalInstances">1</span></label>
                    <div style="display: flex; gap: 5px; margin-top: 5px;">
                        <button class="tool-btn" onclick="previousInstance()" id="prevBtn">◀ Prev</button>
                        <button class="tool-btn" onclick="nextInstance()" id="nextBtn">Next ▶</button>
                    </div>
                </div>
                <div class="control-group">
                    <input type="range" id="instanceSlider" class="range-input" min="1" max="1" value="1"
                        onchange="goToInstance(this.value)">
                </div>
            </div>

            <div class="info-panel">
                <a href="/" class="back-btn">← Back to Gallery</a>
            </div>
        </div>

        <div class="main-viewer">
            <div class="toolbar">
                <div class="tool-group">
                    <button class="tool-btn active" id="wwwcTool" onclick="activateTool('wwwc')">🎛️ W/L</button>
                    <button class="tool-btn" id="zoomTool" onclick="activateTool('zoom')">🔍 Zoom</button>
                    <button class="tool-btn" id="panTool" onclick="activateTool('pan')">✋ Pan</button>
                </div>
                <div class="tool-group">
                    <button class="tool-btn" id="lengthTool" onclick="activateTool('length')">📏 Length</button>
                    <button class="tool-btn" id="angleTool" onclick="activateTool('angle')">📐 Angle</button>
                    <button class="tool-btn" onclick="clearMeasurements()">🗑️ Clear</button>
                </div>
                <div class="tool-group">
                    <button class="tool-btn" onclick="rotateImage(-90)" title="Rotate Left 90°">↺ 90°</button>
                    <button class="tool-btn" onclick="rotateImage(90)" title="Rotate Right 90°">↻ 90°</button>
                    <button class="tool-btn" onclick="rotateImage(180)" title="Rotate 180°">↻ 180°</button>
                    <button class="tool-btn" onclick="resetRotation()" title="Reset Rotation">🔄 0°</button>
                </div>
                <div class="tool-group">
                    <button class="tool-btn" onclick="previousFrame()" title="Previous Frame">⏮️ Prev</button>
                    <span class="frame-display" id="frameDisplay">1/1</span>
                    <button class="tool-btn" onclick="nextFrame()" title="Next Frame">⏭️ Next</button>
                </div>
                <div class="tool-group">
                    <button class="tool-btn" onclick="invertImage()">🔄 Invert</button>
                    <button class="tool-btn" onclick="resetImage()">↺ Reset</button>
                    <span class="rotation-display" id="rotationDisplay">0°</span>
                </div>
            </div>

            <div class="viewport-container">
                <div class="viewport" id="dicomImage"></div>
                <div class="viewport-info" id="viewportInfo">
                    <div>Zoom: <span id="zoomInfo">1.0x</span></div>
                    <div>W/L: <span id="wlInfo">400/40</span></div>
                    <div>Position: <span id="positionInfo">0, 0</span></div>
                </div>
                <div class="loading" id="loadingIndicator">Loading DICOM image...</div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let element;
        let currentTool = 'wwwc';
        let imageId;
        let seriesData = {};
        let currentSeriesUID = '';
        let currentInstanceIndex = 0;
        let currentRotation = 0; // Track current rotation angle
        let currentFrame = 0; // Current frame index (0-based)
        let totalFrames = 1; // Total number of frames in current image
        let currentImage = null; // Store current loaded image
        let measurements = []; // Store all measurements
        let isDrawing = false; // Track if currently drawing a measurement
        let currentMeasurement = null; // Current measurement being drawn

        // Initialize Cornerstone
        function initializeCornerstone() {
            try {
                console.log('Initializing Cornerstone...');
                element = document.getElementById('dicomImage');

                // Enable the element for Cornerstone
                cornerstone.enable(element);
                console.log('Cornerstone element enabled');

                // Configure WADO Image Loader with proper settings
                cornerstoneWADOImageLoader.external.cornerstone = cornerstone;
                cornerstoneWADOImageLoader.external.dicomParser = dicomParser;

                // Configure WADO Image Loader settings
                cornerstoneWADOImageLoader.configure({
                    beforeSend: function (xhr) {
                        console.log('WADO request being sent:', xhr);
                    },
                    errorInterceptor: function (error) {
                        console.error('WADO Image Loader Error:', error);
                        return error;
                    }
                });

                // Register the WADO image loader
                cornerstone.registerImageLoader('wadouri', cornerstoneWADOImageLoader.wadouri.loadImage);

                // Configure Web Image Loader (if available)
                if (typeof cornerstoneWebImageLoader !== 'undefined') {
                    cornerstoneWebImageLoader.external.cornerstone = cornerstone;
                }

                // Initialize Cornerstone Tools (if available)
                if (typeof cornerstoneTools !== 'undefined') {
                    cornerstoneTools.external.cornerstone = cornerstone;
                    if (typeof Hammer !== 'undefined') {
                        cornerstoneTools.external.Hammer = Hammer;
                    }
                    if (typeof cornerstoneMath !== 'undefined') {
                        cornerstoneTools.external.cornerstoneMath = cornerstoneMath;
                    }
                    cornerstoneTools.init();
                    console.log('Cornerstone Tools initialized');

                    // Add tools
                    cornerstoneTools.addTool(cornerstoneTools.WwwcTool);
                    cornerstoneTools.addTool(cornerstoneTools.ZoomTool);
                    cornerstoneTools.addTool(cornerstoneTools.PanTool);
                    cornerstoneTools.addTool(cornerstoneTools.LengthTool);
                    cornerstoneTools.addTool(cornerstoneTools.AngleTool);
                    cornerstoneTools.addTool(cornerstoneTools.RectangleRoiTool);

                    // Set initial tool
                    cornerstoneTools.setToolActive('Wwwc', { mouseButtonMask: 1 });
                    console.log('Tools configured');
                } else {
                    console.warn('Cornerstone Tools not available - tools will be disabled');
                }

                // Load the DICOM image
                loadDicomImage();

            } catch (error) {
                console.error('Error initializing Cornerstone:', error);
                document.getElementById('loadingIndicator').innerHTML =
                    '<div class="error">Error initializing viewer<br>' + error.message + '</div>';
            }
        }

        function loadDicomImage() {
            const filename = '<%= filename %>';
            console.log('Loading DICOM image:', filename);

            // Try different image loading approaches
            const imageIds = [
                `wadouri:http://localhost:3000/dicom-file/${filename}`,
                `wadouri:/dicom-file/${filename}`
            ];

            let currentImageIdIndex = 0;

            function tryLoadImage() {
                if (currentImageIdIndex >= imageIds.length) {
                    console.error('All image loading methods failed');
                    document.getElementById('loadingIndicator').innerHTML =
                        '<div class="error">Failed to load DICOM image<br>Please check the console for details</div>';
                    return;
                }

                imageId = imageIds[currentImageIdIndex];
                console.log('Trying to load with imageId:', imageId);

                cornerstone.loadImage(imageId).then(function (image) {
                    console.log('Successfully loaded DICOM image:', image);
                    cornerstone.displayImage(element, image);

                    // Store current image for frame navigation
                    currentImage = image;

                    // Reset rotation for new image
                    currentRotation = 0;
                    updateRotationDisplay();

                    // Detect and initialize multi-frame data
                    totalFrames = detectMultiFrameData(image);
                    currentFrame = 0;
                    updateFrameDisplay();
                    initializeFrameScroll();

                    console.log(`Image loaded with ${totalFrames} frame(s)`);

                    // Hide loading indicator
                    document.getElementById('loadingIndicator').style.display = 'none';

                    // Update image information
                    updateImageInfo(image);

                    // Set up event listeners
                    setupEventListeners();

                    // Load metadata
                    loadMetadata(filename);

                }).catch(function (err) {
                    console.error(`Error loading DICOM image with ${imageId}:`, err);
                    currentImageIdIndex++;

                    if (currentImageIdIndex < imageIds.length) {
                        console.log('Trying next image loading method...');
                        setTimeout(tryLoadImage, 100);
                    } else {
                        document.getElementById('loadingIndicator').innerHTML =
                            '<div class="error">Error loading DICOM image<br>' + err.message + '</div>';
                    }
                });
            }

            tryLoadImage();
        }

        function updateImageInfo(image) {
            document.getElementById('dimensions').textContent =
                `${image.width} × ${image.height}`;

            // Update window/level controls with image defaults
            const viewport = cornerstone.getViewport(element);
            updateWindowLevelControls(viewport.voi.windowWidth, viewport.voi.windowCenter);
        }

        function loadMetadata(filename) {
            fetch(`/dicom-info/${filename}`)
                .then(response => response.json())
                .then(data => {
                    document.getElementById('patientName').textContent = data.patientName || 'Unknown';
                    document.getElementById('studyDate').textContent = data.studyDate || 'Unknown';
                    document.getElementById('modality').textContent = data.modality || 'Unknown';
                })
                .catch(error => {
                    console.error('Error loading metadata:', error);
                });
        }

        function setupEventListeners() {
            // Viewport change events
            element.addEventListener('cornerstoneimagerendered', function (e) {
                const viewport = e.detail.viewport;
                document.getElementById('zoomInfo').textContent = viewport.scale.toFixed(2) + 'x';
                document.getElementById('wlInfo').textContent =
                    `${Math.round(viewport.voi.windowWidth)}/${Math.round(viewport.voi.windowCenter)}`;

                // Update zoom control
                document.getElementById('zoomLevel').value = viewport.scale;
                document.getElementById('zoomLevelValue').value = viewport.scale.toFixed(2);
            });

            // Mouse move for position tracking
            element.addEventListener('mousemove', function (e) {
                const rect = element.getBoundingClientRect();
                const x = Math.round(e.clientX - rect.left);
                const y = Math.round(e.clientY - rect.top);
                document.getElementById('positionInfo').textContent = `${x}, ${y}`;
            });

            // Window/Level control synchronization
            const windowWidthSlider = document.getElementById('windowWidth');
            const windowWidthValue = document.getElementById('windowWidthValue');
            const windowCenterSlider = document.getElementById('windowCenter');
            const windowCenterValue = document.getElementById('windowCenterValue');

            [windowWidthSlider, windowWidthValue].forEach(control => {
                control.addEventListener('input', function () {
                    const value = parseFloat(this.value);
                    windowWidthSlider.value = value;
                    windowWidthValue.value = value;
                    updateWindowLevel();
                });
            });

            [windowCenterSlider, windowCenterValue].forEach(control => {
                control.addEventListener('input', function () {
                    const value = parseFloat(this.value);
                    windowCenterSlider.value = value;
                    windowCenterValue.value = value;
                    updateWindowLevel();
                });
            });

            // Zoom control
            const zoomSlider = document.getElementById('zoomLevel');
            const zoomValue = document.getElementById('zoomLevelValue');

            [zoomSlider, zoomValue].forEach(control => {
                control.addEventListener('input', function () {
                    const value = parseFloat(this.value);
                    zoomSlider.value = value;
                    zoomValue.value = value.toFixed(2);

                    const viewport = cornerstone.getViewport(element);
                    viewport.scale = value;
                    cornerstone.setViewport(element, viewport);
                });
            });
        }

        function updateWindowLevel() {
            const windowWidth = parseFloat(document.getElementById('windowWidth').value);
            const windowCenter = parseFloat(document.getElementById('windowCenter').value);

            const viewport = cornerstone.getViewport(element);
            viewport.voi.windowWidth = windowWidth;
            viewport.voi.windowCenter = windowCenter;
            cornerstone.setViewport(element, viewport);
        }

        function updateWindowLevelControls(windowWidth, windowCenter) {
            document.getElementById('windowWidth').value = windowWidth;
            document.getElementById('windowWidthValue').value = Math.round(windowWidth);
            document.getElementById('windowCenter').value = windowCenter;
            document.getElementById('windowCenterValue').value = Math.round(windowCenter);
        }

        function activateTool(toolName) {
            // Deactivate all tools
            cornerstoneTools.setToolPassive('Wwwc');
            cornerstoneTools.setToolPassive('Zoom');
            cornerstoneTools.setToolPassive('Pan');
            cornerstoneTools.setToolPassive('Length');
            cornerstoneTools.setToolPassive('Angle');
            cornerstoneTools.setToolPassive('RectangleRoi');

            // Remove active class from all buttons
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));

            // Activate selected tool
            switch (toolName) {
                case 'wwwc':
                    cornerstoneTools.setToolActive('Wwwc', { mouseButtonMask: 1 });
                    break;
                case 'zoom':
                    cornerstoneTools.setToolActive('Zoom', { mouseButtonMask: 1 });
                    break;
                case 'pan':
                    cornerstoneTools.setToolActive('Pan', { mouseButtonMask: 1 });
                    break;
                case 'length':
                    cornerstoneTools.setToolActive('Length', { mouseButtonMask: 1 });
                    break;
                case 'angle':
                    cornerstoneTools.setToolActive('Angle', { mouseButtonMask: 1 });
                    break;
                case 'rectangleRoi':
                    cornerstoneTools.setToolActive('RectangleRoi', { mouseButtonMask: 1 });
                    break;
            }

            // Add active class to selected button
            document.getElementById(toolName + 'Tool').classList.add('active');
            currentTool = toolName;
        }

        function resetView() {
            cornerstone.reset(element);
            const viewport = cornerstone.getViewport(element);
            updateWindowLevelControls(viewport.voi.windowWidth, viewport.voi.windowCenter);
        }

        function invertImage() {
            const viewport = cornerstone.getViewport(element);
            viewport.invert = !viewport.invert;
            cornerstone.setViewport(element, viewport);
        }

        function resetImage() {
            cornerstone.reset(element);
            currentRotation = 0; // Reset rotation when resetting image
            updateRotationDisplay();
            const viewport = cornerstone.getViewport(element);
            updateWindowLevelControls(viewport.voi.windowWidth, viewport.voi.windowCenter);
        }

        // Rotation functions
        function rotateImage(angle) {
            if (!element || !cornerstone.getEnabledElement(element)) {
                console.warn('Cannot rotate: element not enabled');
                return;
            }

            try {
                // Update current rotation
                currentRotation = (currentRotation + angle) % 360;
                if (currentRotation < 0) {
                    currentRotation += 360;
                }

                // Get current viewport
                const viewport = cornerstone.getViewport(element);

                // Set rotation
                viewport.rotation = (currentRotation * Math.PI) / 180; // Convert to radians

                // Apply the viewport changes
                cornerstone.setViewport(element, viewport);

                // Update display
                updateRotationDisplay();

                console.log(`Rotated image by ${angle}°, current rotation: ${currentRotation}°`);

            } catch (error) {
                console.error('Error rotating image:', error);
            }
        }

        function resetRotation() {
            if (!element || !cornerstone.getEnabledElement(element)) {
                console.warn('Cannot reset rotation: element not enabled');
                return;
            }

            try {
                currentRotation = 0;

                // Get current viewport
                const viewport = cornerstone.getViewport(element);

                // Reset rotation
                viewport.rotation = 0;

                // Apply the viewport changes
                cornerstone.setViewport(element, viewport);

                // Update display
                updateRotationDisplay();

                console.log('Reset rotation to 0°');

            } catch (error) {
                console.error('Error resetting rotation:', error);
            }
        }

        function updateRotationDisplay() {
            const rotationDisplay = document.getElementById('rotationDisplay');
            if (rotationDisplay) {
                rotationDisplay.textContent = `${currentRotation}°`;
            }
        }

        // Frame navigation functions for multi-frame DICOM files
        function nextFrame() {
            if (!currentImage || totalFrames <= 1) {
                console.log('No multi-frame data available or only single frame');
                return;
            }

            if (currentFrame < totalFrames - 1) {
                currentFrame++;
                displayFrame(currentFrame);
                updateFrameDisplay();
                console.log(`Switched to frame ${currentFrame + 1}/${totalFrames}`);
            } else {
                console.log('Already at last frame');
            }
        }

        function previousFrame() {
            if (!currentImage || totalFrames <= 1) {
                console.log('No multi-frame data available or only single frame');
                return;
            }

            if (currentFrame > 0) {
                currentFrame--;
                displayFrame(currentFrame);
                updateFrameDisplay();
                console.log(`Switched to frame ${currentFrame + 1}/${totalFrames}`);
            } else {
                console.log('Already at first frame');
            }
        }

        function displayFrame(frameIndex) {
            if (!element || !currentImage) {
                console.error('Cannot display frame: element or image not available');
                return;
            }

            try {
                // For multi-frame DICOM files, we need to create a new image ID with frame index
                const baseImageId = imageId.split('#frame=')[0]; // Remove existing frame parameter
                const frameImageId = `${baseImageId}#frame=${frameIndex}`;

                console.log(`Loading frame ${frameIndex} with imageId: ${frameImageId}`);

                cornerstone.loadImage(frameImageId).then(function (image) {
                    cornerstone.displayImage(element, image);

                    // Maintain current viewport settings (zoom, pan, rotation, windowing)
                    const viewport = cornerstone.getViewport(element);
                    viewport.rotation = (currentRotation * Math.PI) / 180;
                    cornerstone.setViewport(element, viewport);

                    // Redraw measurements after frame change
                    setTimeout(() => {
                        redrawMeasurements();
                    }, 100);

                    console.log(`Successfully displayed frame ${frameIndex + 1}`);
                }).catch(function (error) {
                    console.error(`Error loading frame ${frameIndex}:`, error);

                    // Fallback: try to extract frame from pixel data if available
                    if (currentImage.getPixelData && typeof currentImage.getPixelData === 'function') {
                        try {
                            displayFrameFromPixelData(frameIndex);
                        } catch (fallbackError) {
                            console.error('Fallback frame display also failed:', fallbackError);
                        }
                    }
                });

            } catch (error) {
                console.error('Error in displayFrame:', error);
            }
        }

        function displayFrameFromPixelData(frameIndex) {
            // This is a fallback method for when frame-specific image IDs don't work
            // We'll try to extract the specific frame from the pixel data
            console.log(`Attempting fallback frame display for frame ${frameIndex}`);

            if (!currentImage.getPixelData) {
                throw new Error('No pixel data access method available');
            }

            // For now, we'll just re-display the current image
            // In a full implementation, you'd extract the specific frame's pixel data
            cornerstone.displayImage(element, currentImage);

            // Maintain viewport settings
            const viewport = cornerstone.getViewport(element);
            viewport.rotation = (currentRotation * Math.PI) / 180;
            cornerstone.setViewport(element, viewport);
        }

        function updateFrameDisplay() {
            // Update toolbar frame display
            const frameDisplay = document.getElementById('frameDisplay');
            if (frameDisplay) {
                frameDisplay.textContent = `${currentFrame + 1}/${totalFrames}`;
            }

            // Update sidebar frame counter
            const frameCounter = document.getElementById('frameCounter');
            if (frameCounter) {
                frameCounter.textContent = `${currentFrame + 1}/${totalFrames}`;
            }

            // Update scroll position and indicator
            updateFrameScrollPosition();
        }

        function initializeFrameScroll() {
            const scrollArea = document.getElementById('frameScrollArea');
            const scrollContent = document.getElementById('frameScrollContent');
            const scrollIndicator = document.getElementById('frameScrollIndicator');

            if (!scrollArea || !scrollContent || totalFrames <= 1) {
                return;
            }

            // Set content height based on frame count
            // More frames = taller content for more precise scrolling
            const contentHeight = Math.max(1000, totalFrames * 20);
            scrollContent.style.height = contentHeight + 'px';

            // Add scroll event listener
            scrollArea.addEventListener('scroll', handleFrameScroll);

            // Initialize scroll position for current frame
            updateFrameScrollPosition();

            console.log(`Initialized frame scroll for ${totalFrames} frames`);
        }

        function handleFrameScroll() {
            const scrollArea = document.getElementById('frameScrollArea');
            if (!scrollArea || totalFrames <= 1) return;

            // Calculate which frame should be displayed based on scroll position
            const scrollTop = scrollArea.scrollTop;
            const scrollHeight = scrollArea.scrollHeight - scrollArea.clientHeight;

            if (scrollHeight <= 0) return;

            // Convert scroll position to frame index
            const scrollRatio = scrollTop / scrollHeight;
            const targetFrame = Math.round(scrollRatio * (totalFrames - 1));

            // Only change frame if it's different from current
            if (targetFrame !== currentFrame && targetFrame >= 0 && targetFrame < totalFrames) {
                currentFrame = targetFrame;
                displayFrame(currentFrame);
                updateFrameCounter();
                updateScrollIndicator();

                console.log(`Scroll navigation: Frame ${currentFrame + 1}/${totalFrames}`);
            }
        }

        function updateFrameScrollPosition() {
            const scrollArea = document.getElementById('frameScrollArea');
            if (!scrollArea || totalFrames <= 1) return;

            // Calculate scroll position for current frame
            const scrollHeight = scrollArea.scrollHeight - scrollArea.clientHeight;
            const frameRatio = totalFrames > 1 ? currentFrame / (totalFrames - 1) : 0;
            const targetScrollTop = frameRatio * scrollHeight;

            // Temporarily remove scroll listener to prevent recursion
            scrollArea.removeEventListener('scroll', handleFrameScroll);
            scrollArea.scrollTop = targetScrollTop;

            // Re-add scroll listener after a short delay
            setTimeout(() => {
                scrollArea.addEventListener('scroll', handleFrameScroll);
            }, 100);

            updateScrollIndicator();
        }

        function updateScrollIndicator() {
            const scrollIndicator = document.getElementById('frameScrollIndicator');
            if (!scrollIndicator || totalFrames <= 1) return;

            // Position indicator based on current frame
            const frameRatio = totalFrames > 1 ? currentFrame / (totalFrames - 1) : 0;
            const indicatorTop = frameRatio * (200 - 20); // 200px container height - 20px indicator height

            scrollIndicator.style.top = indicatorTop + 'px';
        }

        function updateFrameCounter() {
            // Update only the frame counter (without scroll position)
            const frameDisplay = document.getElementById('frameDisplay');
            if (frameDisplay) {
                frameDisplay.textContent = `${currentFrame + 1}/${totalFrames}`;
            }

            const frameCounter = document.getElementById('frameCounter');
            if (frameCounter) {
                frameCounter.textContent = `${currentFrame + 1}/${totalFrames}`;
            }
        }

        function goToFrame(frameIndex) {
            if (!currentImage || totalFrames <= 1) {
                console.log('No multi-frame data available');
                return;
            }

            frameIndex = parseInt(frameIndex);
            if (frameIndex < 0 || frameIndex >= totalFrames) {
                console.warn(`Invalid frame index: ${frameIndex}. Valid range: 0-${totalFrames - 1}`);
                return;
            }

            if (frameIndex === currentFrame) {
                console.log(`Already at frame ${frameIndex + 1}`);
                return;
            }

            currentFrame = frameIndex;
            displayFrame(currentFrame);
            updateFrameDisplay();
            console.log(`Jumped to frame ${currentFrame + 1}/${totalFrames}`);
        }

        function detectMultiFrameData(image) {
            // Detect if this is a multi-frame DICOM file
            let detectedFrames = 1;

            try {
                // Check various DICOM tags that might indicate multi-frame data
                if (image.data && image.data.string) {
                    // Look for NumberOfFrames tag (0028,0008)
                    const numberOfFramesTag = image.data.string('x00280008');
                    if (numberOfFramesTag) {
                        detectedFrames = parseInt(numberOfFramesTag) || 1;
                        console.log(`Detected ${detectedFrames} frames from NumberOfFrames tag`);
                    }
                }

                // Alternative: check if pixel data suggests multiple frames
                if (detectedFrames === 1 && image.width && image.height) {
                    const expectedSingleFrameSize = image.width * image.height * (image.bitsAllocated / 8);
                    const actualDataSize = image.getPixelData ? image.getPixelData().length : 0;

                    if (actualDataSize > expectedSingleFrameSize * 1.5) {
                        // Estimate number of frames based on data size
                        detectedFrames = Math.floor(actualDataSize / expectedSingleFrameSize);
                        console.log(`Estimated ${detectedFrames} frames based on pixel data size`);
                    }
                }

            } catch (error) {
                console.warn('Error detecting multi-frame data:', error);
            }

            return Math.max(1, detectedFrames);
        }

        // Series navigation functions
        function loadSeriesData() {
            // Load series files for the current DICOM file
            fetch('/series-files/<%= filename %>')
                .then(response => response.json())
                .then(data => {
                    const studyUID = data.studyUID || 'unknown';
                    const seriesUID = data.seriesUID || 'unknown';

                    if (!seriesData[studyUID]) {
                        seriesData[studyUID] = {};
                    }

                    // Load metadata for series description
                    fetch('/dicom-info/<%= filename %>')
                        .then(response => response.json())
                        .then(metaData => {
                            seriesData[studyUID][seriesUID] = {
                                description: metaData.seriesDescription || 'Unknown Series',
                                instances: data.files || ['<%= filename %>']
                            };

                            currentSeriesUID = seriesUID;
                            // Find current instance index
                            currentInstanceIndex = data.files.indexOf('<%= filename %>');
                            if (currentInstanceIndex === -1) currentInstanceIndex = 0;

                            updateSeriesNavigation();
                        });
                })
                .catch(error => {
                    console.error('Error loading series data:', error);
                    // Fallback to single file
                    seriesData['unknown'] = {
                        'unknown': {
                            description: 'Single Image',
                            instances: ['<%= filename %>']
                        }
                    };
                    currentSeriesUID = 'unknown';
                    currentInstanceIndex = 0;
                    updateSeriesNavigation();
                });
        }

        function updateSeriesNavigation() {
            const seriesNav = document.getElementById('seriesNavigation');
            const selector = document.getElementById('seriesSelector');
            const currentInstance = document.getElementById('currentInstance');
            const totalInstances = document.getElementById('totalInstances');
            const instanceSlider = document.getElementById('instanceSlider');

            // Show navigation if we have series data
            if (Object.keys(seriesData).length > 0) {
                seriesNav.style.display = 'block';

                // Populate series selector
                selector.innerHTML = '';
                Object.keys(seriesData).forEach(studyUID => {
                    Object.keys(seriesData[studyUID]).forEach(seriesUID => {
                        const series = seriesData[studyUID][seriesUID];
                        const option = document.createElement('option');
                        option.value = seriesUID;
                        option.textContent = series.description;
                        option.selected = seriesUID === currentSeriesUID;
                        selector.appendChild(option);
                    });
                });

                // Update instance navigation
                const currentSeries = getCurrentSeries();
                if (currentSeries) {
                    const totalCount = currentSeries.instances.length;
                    currentInstance.textContent = currentInstanceIndex + 1;
                    totalInstances.textContent = totalCount;

                    instanceSlider.min = 1;
                    instanceSlider.max = totalCount;
                    instanceSlider.value = currentInstanceIndex + 1;

                    // Update button states
                    document.getElementById('prevBtn').disabled = currentInstanceIndex === 0;
                    document.getElementById('nextBtn').disabled = currentInstanceIndex === totalCount - 1;
                }
            }
        }

        function getCurrentSeries() {
            for (const studyUID in seriesData) {
                if (seriesData[studyUID][currentSeriesUID]) {
                    return seriesData[studyUID][currentSeriesUID];
                }
            }
            return null;
        }

        function switchSeries() {
            const selector = document.getElementById('seriesSelector');
            currentSeriesUID = selector.value;
            currentInstanceIndex = 0;

            const series = getCurrentSeries();
            if (series && series.instances.length > 0) {
                loadDicomImageByFilename(series.instances[0]);
            }

            updateSeriesNavigation();
        }

        function previousInstance() {
            const series = getCurrentSeries();
            if (series && currentInstanceIndex > 0) {
                currentInstanceIndex--;
                loadDicomImageByFilename(series.instances[currentInstanceIndex]);
                updateSeriesNavigation();
            }
        }

        function nextInstance() {
            const series = getCurrentSeries();
            if (series && currentInstanceIndex < series.instances.length - 1) {
                currentInstanceIndex++;
                loadDicomImageByFilename(series.instances[currentInstanceIndex]);
                updateSeriesNavigation();
            }
        }

        function goToInstance(instanceNumber) {
            const series = getCurrentSeries();
            if (series) {
                currentInstanceIndex = parseInt(instanceNumber) - 1;
                loadDicomImageByFilename(series.instances[currentInstanceIndex]);
                updateSeriesNavigation();
            }
        }

        function loadDicomImageByFilename(filename) {
            const newImageId = `wadouri:/dicom-file/${filename}`;

            cornerstone.loadImage(newImageId).then(function (image) {
                cornerstone.displayImage(element, image);

                // Store current image for frame navigation
                currentImage = image;

                // Reset rotation for new image
                currentRotation = 0;
                updateRotationDisplay();

                // Detect and initialize multi-frame data
                totalFrames = detectMultiFrameData(image);
                currentFrame = 0;
                updateFrameDisplay();
                initializeFrameScroll();

                console.log(`Series image loaded with ${totalFrames} frame(s)`);

                updateImageInfo(image);
                loadMetadata(filename);
            }).catch(function (err) {
                console.error('Error loading image:', err);
            });
        }

        // Initialize when page loads
        // Keyboard shortcuts for frame navigation
        document.addEventListener('keydown', function (event) {
            // Only handle shortcuts when not typing in input fields
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                return;
            }

            switch (event.key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    event.preventDefault();
                    previousFrame();
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    event.preventDefault();
                    nextFrame();
                    break;
                case 'Home':
                    event.preventDefault();
                    if (totalFrames > 1) {
                        currentFrame = 0;
                        displayFrame(currentFrame);
                        updateFrameDisplay();
                    }
                    break;
                case 'End':
                    event.preventDefault();
                    if (totalFrames > 1) {
                        currentFrame = totalFrames - 1;
                        displayFrame(currentFrame);
                        updateFrameDisplay();
                    }
                    break;
            }
        });

        // Tool activation function
        function activateTool(toolName) {
            // Remove active class from all tool buttons
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));

            // Add active class to selected tool
            const toolBtn = document.getElementById(toolName + 'Tool');
            if (toolBtn) {
                toolBtn.classList.add('active');
            }

            currentTool = toolName;
            console.log(`Activated tool: ${toolName}`);

            // Update cursor based on tool
            const element = document.getElementById('dicomImage');
            if (element) {
                switch (toolName) {
                    case 'wwwc':
                        element.style.cursor = 'crosshair';
                        break;
                    case 'zoom':
                        element.style.cursor = 'zoom-in';
                        break;
                    case 'pan':
                        element.style.cursor = 'move';
                        break;
                    case 'length':
                        element.style.cursor = 'crosshair';
                        break;
                    case 'angle':
                        element.style.cursor = 'crosshair';
                        break;
                    default:
                        element.style.cursor = 'default';
                }
            }
        }

        // Clear all measurements
        function clearMeasurements() {
            measurements = [];
            redrawMeasurements();
            console.log('All measurements cleared');
        }

        // Redraw all measurements on the canvas
        function redrawMeasurements() {
            const element = document.getElementById('dicomImage');
            if (!element) return;

            // Clear existing measurement overlays
            const existingOverlays = element.querySelectorAll('.measurement-overlay');
            existingOverlays.forEach(overlay => overlay.remove());

            // Redraw each measurement
            measurements.forEach((measurement, index) => {
                drawMeasurement(measurement, index);
            });
        }

        // Draw a measurement on the image
        function drawMeasurement(measurement, index) {
            const element = document.getElementById('dicomImage');
            if (!element) return;

            const canvas = element.querySelector('canvas');
            if (!canvas) return;

            const rect = canvas.getBoundingClientRect();
            const overlay = document.createElement('div');
            overlay.className = 'measurement-overlay';
            overlay.style.position = 'absolute';
            overlay.style.pointerEvents = 'none';
            overlay.style.zIndex = '1000';

            if (measurement.type === 'length') {
                // Draw length measurement
                const line = document.createElement('div');
                line.style.position = 'absolute';
                line.style.background = '#00ff88';
                line.style.height = '2px';
                line.style.transformOrigin = 'left center';

                const dx = measurement.end.x - measurement.start.x;
                const dy = measurement.end.y - measurement.start.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;

                line.style.width = length + 'px';
                line.style.left = measurement.start.x + 'px';
                line.style.top = measurement.start.y + 'px';
                line.style.transform = `rotate(${angle}deg)`;

                // Add measurement text
                const text = document.createElement('div');
                text.style.position = 'absolute';
                text.style.background = 'rgba(0, 255, 136, 0.8)';
                text.style.color = '#000';
                text.style.padding = '2px 6px';
                text.style.borderRadius = '3px';
                text.style.fontSize = '12px';
                text.style.fontWeight = 'bold';
                text.style.left = (measurement.start.x + measurement.end.x) / 2 + 'px';
                text.style.top = (measurement.start.y + measurement.end.y) / 2 - 20 + 'px';
                text.textContent = `${length.toFixed(1)}px`;

                overlay.appendChild(line);
                overlay.appendChild(text);

            } else if (measurement.type === 'angle') {
                // Draw angle measurement (three points)
                if (measurement.points && measurement.points.length === 3) {
                    const [p1, p2, p3] = measurement.points;

                    // Draw two lines
                    const line1 = document.createElement('div');
                    const line2 = document.createElement('div');

                    [line1, line2].forEach(line => {
                        line.style.position = 'absolute';
                        line.style.background = '#ff6600';
                        line.style.height = '2px';
                        line.style.transformOrigin = 'left center';
                    });

                    // Line 1: p2 to p1
                    const dx1 = p1.x - p2.x;
                    const dy1 = p1.y - p2.y;
                    const length1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                    const angle1 = Math.atan2(dy1, dx1) * 180 / Math.PI;

                    line1.style.width = length1 + 'px';
                    line1.style.left = p2.x + 'px';
                    line1.style.top = p2.y + 'px';
                    line1.style.transform = `rotate(${angle1}deg)`;

                    // Line 2: p2 to p3
                    const dx2 = p3.x - p2.x;
                    const dy2 = p3.y - p2.y;
                    const length2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                    const angle2 = Math.atan2(dy2, dx2) * 180 / Math.PI;

                    line2.style.width = length2 + 'px';
                    line2.style.left = p2.x + 'px';
                    line2.style.top = p2.y + 'px';
                    line2.style.transform = `rotate(${angle2}deg)`;

                    // Calculate angle between lines
                    const angleDiff = Math.abs(angle2 - angle1);
                    const finalAngle = angleDiff > 180 ? 360 - angleDiff : angleDiff;

                    // Add angle text
                    const text = document.createElement('div');
                    text.style.position = 'absolute';
                    text.style.background = 'rgba(255, 102, 0, 0.8)';
                    text.style.color = '#fff';
                    text.style.padding = '2px 6px';
                    text.style.borderRadius = '3px';
                    text.style.fontSize = '12px';
                    text.style.fontWeight = 'bold';
                    text.style.left = p2.x + 10 + 'px';
                    text.style.top = p2.y - 20 + 'px';
                    text.textContent = `${finalAngle.toFixed(1)}°`;

                    overlay.appendChild(line1);
                    overlay.appendChild(line2);
                    overlay.appendChild(text);
                }
            }

            element.appendChild(overlay);
        }

        // File browser functions
        function toggleFileBrowser() {
            const fileBrowser = document.getElementById('fileBrowser');
            fileBrowser.classList.toggle('collapsed');
        }

        function loadFileList() {
            console.log('Loading file list...');
            fetch('/api/files')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(files => {
                    console.log('Files loaded:', files.length);
                    const fileList = document.getElementById('fileList');
                    if (!fileList) {
                        console.error('File list element not found');
                        return;
                    }

                    fileList.innerHTML = '';

                    files.forEach(file => {
                        const fileItem = document.createElement('div');
                        fileItem.className = 'file-item';
                        fileItem.textContent = file.name;
                        fileItem.onclick = () => switchToFile(file.name);

                        // Mark current file as active
                        if (file.name === '<%= filename %>') {
                            fileItem.classList.add('active');
                        }

                        fileList.appendChild(fileItem);
                    });

                    console.log('File list populated successfully');
                })
                .catch(error => {
                    console.error('Error loading file list:', error);
                    const fileList = document.getElementById('fileList');
                    if (fileList) {
                        fileList.innerHTML = '<div style="color: #ff6666; padding: 10px;">Error loading files</div>';
                    }
                });
        }

        function switchToFile(filename) {
            if (filename === '<%= filename %>') {
                console.log('Already viewing this file');
                return;
            }

            // Show loading state
            const fileItems = document.querySelectorAll('.file-item');
            fileItems.forEach(item => {
                if (item.textContent === filename) {
                    item.classList.add('loading');
                }
            });

            // Navigate to new file
            window.location.href = `/viewer/${filename}`;
        }

        // Add mouse event handlers for measurements
        function addMeasurementHandlers() {
            const element = document.getElementById('dicomImage');
            if (!element) return;

            let mouseDownHandler = function (e) {
                if (currentTool === 'length' || currentTool === 'angle') {
                    e.preventDefault();
                    const rect = element.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    if (currentTool === 'length') {
                        if (!isDrawing) {
                            // Start length measurement
                            isDrawing = true;
                            currentMeasurement = {
                                type: 'length',
                                start: { x, y },
                                end: { x, y }
                            };
                        } else {
                            // Finish length measurement
                            currentMeasurement.end = { x, y };
                            measurements.push(currentMeasurement);
                            drawMeasurement(currentMeasurement, measurements.length - 1);
                            isDrawing = false;
                            currentMeasurement = null;
                            console.log('Length measurement completed');
                        }
                    } else if (currentTool === 'angle') {
                        if (!isDrawing) {
                            // Start angle measurement
                            isDrawing = true;
                            currentMeasurement = {
                                type: 'angle',
                                points: [{ x, y }]
                            };
                        } else if (currentMeasurement.points.length === 1) {
                            // Add second point
                            currentMeasurement.points.push({ x, y });
                        } else if (currentMeasurement.points.length === 2) {
                            // Add third point and finish
                            currentMeasurement.points.push({ x, y });
                            measurements.push(currentMeasurement);
                            drawMeasurement(currentMeasurement, measurements.length - 1);
                            isDrawing = false;
                            currentMeasurement = null;
                            console.log('Angle measurement completed');
                        }
                    }
                }
            };

            element.addEventListener('mousedown', mouseDownHandler);
        }

        document.addEventListener('DOMContentLoaded', function () {
            console.log('DOM Content Loaded - initializing viewer...');
            try {
                initializeCornerstone();
                loadSeriesData();

                // Load file list after a short delay to ensure DOM is ready
                setTimeout(() => {
                    try {
                        loadFileList();
                    } catch (error) {
                        console.error('Error loading file list:', error);
                    }
                }, 500);

                setTimeout(() => {
                    try {
                        addMeasurementHandlers();
                    } catch (error) {
                        console.error('Error adding measurement handlers:', error);
                    }
                }, 1000);

            } catch (error) {
                console.error('Error during initialization:', error);
            }
        });
    </script>
</body>

</html>